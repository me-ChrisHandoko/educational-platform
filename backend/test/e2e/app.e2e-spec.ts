import { Test, TestingModule } from '@nestjs/testing';\nimport { INestApplication, ValidationPipe } from '@nestjs/common';\nimport * as request from 'supertest';\nimport { AppModule } from '../../src/app.module';\nimport { TestDbHelper } from '../helpers/test-db.helper';\nimport { AuthTestHelper } from '../helpers/auth.helper';\n\ndescribe('Application E2E Tests', () => {\n  let app: INestApplication;\n  let testUser: any;\n  let testSchool: any;\n  let accessToken: string;\n\n  beforeAll(async () => {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [AppModule],\n    }).compile();\n\n    app = moduleFixture.createNestApplication();\n    app.useGlobalPipes(new ValidationPipe({ transform: true, whitelist: true }));\n    \n    await app.init();\n    await TestDbHelper.clearDatabase();\n  });\n\n  beforeEach(async () => {\n    await TestDbHelper.clearDatabase();\n    \n    // Set up test data\n    testSchool = await TestDbHelper.createTestSchool();\n    testUser = await TestDbHelper.createTestUser({\n      email: 'e2e@test.com',\n      password: await AuthTestHelper.hashPassword('E2EPassword123!'),\n      schoolId: testSchool.id,\n      role: 'STUDENT',\n    });\n\n    // Get access token for authenticated requests\n    const loginResponse = await request(app.getHttpServer())\n      .post('/auth/login')\n      .send({\n        email: testUser.email,\n        password: 'E2EPassword123!',\n      })\n      .expect(200);\n\n    accessToken = loginResponse.body.tokens.accessToken;\n  });\n\n  afterAll(async () => {\n    await TestDbHelper.clearDatabase();\n    await TestDbHelper.disconnect();\n    await app.close();\n  });\n\n  describe('Application Health and Status', () => {\n    it('should return Hello World from root endpoint', () => {\n      return request(app.getHttpServer())\n        .get('/')\n        .expect(200)\n        .expect('Hello World!');\n    });\n\n    it('should return authentication health status', () => {\n      return request(app.getHttpServer())\n        .get('/auth/health')\n        .expect(200)\n        .expect((res) => {\n          expect(res.body).toMatchObject({\n            status: 'ok',\n            service: 'authentication',\n            timestamp: expect.any(String),\n          });\n        });\n    });\n  });\n\n  describe('Complete User Journey', () => {\n    it('should handle complete user registration and authentication flow', async () => {\n      // Step 1: Register new user\n      const newUserData = {\n        email: 'journey@test.com',\n        password: 'JourneyPassword123!',\n        confirmPassword: 'JourneyPassword123!',\n        firstName: 'Journey',\n        lastName: 'User',\n        schoolId: testSchool.id,\n        role: 'STUDENT',\n        phoneNumber: '+1234567890',\n      };\n\n      const registerResponse = await request(app.getHttpServer())\n        .post('/auth/register')\n        .send(newUserData)\n        .expect(201);\n\n      expect(registerResponse.body).toMatchObject({\n        id: expect.any(String),\n        email: newUserData.email,\n        role: newUserData.role,\n        status: 'ACTIVE',\n      });\n\n      // Step 2: Login with new user\n      const loginResponse = await request(app.getHttpServer())\n        .post('/auth/login')\n        .send({\n          email: newUserData.email,\n          password: newUserData.password,\n        })\n        .expect(200);\n\n      const { accessToken: userAccessToken, refreshToken } = loginResponse.body.tokens;\n      expect(accessToken).toBeDefined();\n      expect(refreshToken).toBeDefined();\n\n      // Step 3: Access protected profile endpoint\n      const profileResponse = await request(app.getHttpServer())\n        .get('/auth/profile')\n        .set('Authorization', `Bearer ${userAccessToken}`)\n        .expect(200);\n\n      expect(profileResponse.body).toMatchObject({\n        id: registerResponse.body.id,\n        role: newUserData.role,\n        schoolId: newUserData.schoolId,\n      });\n\n      // Step 4: Change password\n      await request(app.getHttpServer())\n        .post('/auth/change-password')\n        .set('Authorization', `Bearer ${userAccessToken}`)\n        .send({\n          currentPassword: newUserData.password,\n          newPassword: 'NewJourneyPassword123!',\n          confirmPassword: 'NewJourneyPassword123!',\n        })\n        .expect(200);\n\n      // Step 5: Verify old password no longer works\n      await request(app.getHttpServer())\n        .post('/auth/login')\n        .send({\n          email: newUserData.email,\n          password: newUserData.password,\n        })\n        .expect(401);\n\n      // Step 6: Login with new password\n      await request(app.getHttpServer())\n        .post('/auth/login')\n        .send({\n          email: newUserData.email,\n          password: 'NewJourneyPassword123!',\n        })\n        .expect(200);\n\n      // Step 7: Refresh tokens\n      const refreshResponse = await request(app.getHttpServer())\n        .post('/auth/refresh')\n        .send({\n          refreshToken,\n        })\n        .expect(200);\n\n      expect(refreshResponse.body).toMatchObject({\n        accessToken: expect.any(String),\n        refreshToken: expect.any(String),\n      });\n\n      // Step 8: Logout\n      await request(app.getHttpServer())\n        .post('/auth/logout')\n        .set('Authorization', `Bearer ${refreshResponse.body.accessToken}`)\n        .expect(200);\n    });\n\n    it('should handle invalid authentication flows gracefully', async () => {\n      // Attempt to access protected endpoint without token\n      await request(app.getHttpServer())\n        .get('/auth/profile')\n        .expect(401);\n\n      // Attempt to login with invalid credentials\n      await request(app.getHttpServer())\n        .post('/auth/login')\n        .send({\n          email: 'invalid@test.com',\n          password: 'InvalidPassword123!',\n        })\n        .expect(401);\n\n      // Attempt to register with invalid data\n      await request(app.getHttpServer())\n        .post('/auth/register')\n        .send({\n          email: 'invalid-email',\n          password: 'weak',\n          confirmPassword: 'different',\n        })\n        .expect(400);\n\n      // Attempt to refresh with invalid token\n      await request(app.getHttpServer())\n        .post('/auth/refresh')\n        .send({\n          refreshToken: 'invalid-refresh-token',\n        })\n        .expect(401);\n    });\n  });\n\n  describe('Security and Edge Cases', () => {\n    it('should prevent duplicate registrations', async () => {\n      const userData = {\n        email: testUser.email, // Use existing email\n        password: 'DuplicatePassword123!',\n        confirmPassword: 'DuplicatePassword123!',\n        firstName: 'Duplicate',\n        lastName: 'User',\n        schoolId: testSchool.id,\n        role: 'STUDENT',\n      };\n\n      await request(app.getHttpServer())\n        .post('/auth/register')\n        .send(userData)\n        .expect(409);\n    });\n\n    it('should validate JWT tokens properly', async () => {\n      // Test with malformed token\n      await request(app.getHttpServer())\n        .get('/auth/profile')\n        .set('Authorization', 'Bearer malformed-token')\n        .expect(401);\n\n      // Test with expired token\n      const expiredToken = await AuthTestHelper.generateExpiredJwtToken();\n      await request(app.getHttpServer())\n        .get('/auth/profile')\n        .set('Authorization', `Bearer ${expiredToken}`)\n        .expect(401);\n\n      // Test with missing Bearer prefix\n      await request(app.getHttpServer())\n        .get('/auth/profile')\n        .set('Authorization', accessToken)\n        .expect(401);\n    });\n\n    it('should handle CORS and security headers', async () => {\n      const response = await request(app.getHttpServer())\n        .options('/auth/login')\n        .expect(204);\n\n      // Verify CORS headers are present (if configured)\n      // This would depend on your CORS configuration\n    });\n\n    it('should rate limit authentication attempts', async () => {\n      // This test would require rate limiting middleware to be configured\n      // For demonstration, we'll test that multiple requests are handled\n      const requests = Array(10).fill(null).map(() =>\n        request(app.getHttpServer())\n          .post('/auth/login')\n          .send({\n            email: 'nonexistent@test.com',\n            password: 'InvalidPassword123!',\n          })\n      );\n\n      const responses = await Promise.all(requests);\n      // All should return 401 (unauthorized) rather than 429 (rate limited)\n      // unless rate limiting is specifically implemented\n      responses.forEach(response => {\n        expect([401, 429]).toContain(response.status);\n      });\n    });\n  });\n\n  describe('Input Validation and Sanitization', () => {\n    it('should validate email formats strictly', async () => {\n      const invalidEmails = [\n        'invalid-email',\n        '@domain.com',\n        'user@',\n        'user@.com',\n        'user..user@domain.com',\n        'user@domain',\n      ];\n\n      for (const email of invalidEmails) {\n        await request(app.getHttpServer())\n          .post('/auth/login')\n          .send({\n            email,\n            password: 'Password123!',\n          })\n          .expect(400);\n      }\n    });\n\n    it('should enforce password complexity requirements', async () => {\n      const weakPasswords = [\n        'password',\n        '12345678',\n        'PASSWORD',\n        'Password',\n        'password123',\n        'PASSWORD123',\n        'Password123',\n      ];\n\n      for (const password of weakPasswords) {\n        await request(app.getHttpServer())\n          .post('/auth/register')\n          .send({\n            email: `test${Date.now()}@test.com`,\n            password,\n            confirmPassword: password,\n            firstName: 'Test',\n            lastName: 'User',\n            schoolId: testSchool.id,\n            role: 'STUDENT',\n          })\n          .expect(400);\n      }\n    });\n\n    it('should sanitize input data', async () => {\n      // Test with XSS payloads\n      const xssPayloads = [\n        '<script>alert(\"xss\")</script>',\n        'javascript:alert(\"xss\")',\n        '<img src=x onerror=alert(\"xss\")>',\n      ];\n\n      for (const payload of xssPayloads) {\n        const response = await request(app.getHttpServer())\n          .post('/auth/register')\n          .send({\n            email: 'test@test.com',\n            password: 'ValidPassword123!',\n            confirmPassword: 'ValidPassword123!',\n            firstName: payload,\n            lastName: 'User',\n            schoolId: testSchool.id,\n            role: 'STUDENT',\n          });\n\n        // Should either reject the input or sanitize it\n        if (response.status === 201) {\n          expect(response.body.profile.firstName).not.toContain('<script>');\n          expect(response.body.profile.firstName).not.toContain('javascript:');\n        }\n      }\n    });\n  });\n\n  describe('Performance and Load', () => {\n    it('should handle concurrent authentication requests', async () => {\n      const concurrentUsers = 20;\n      const loginPromises = Array(concurrentUsers).fill(null).map((_, index) =>\n        request(app.getHttpServer())\n          .post('/auth/register')\n          .send({\n            email: `concurrent${index}@test.com`,\n            password: 'ConcurrentPassword123!',\n            confirmPassword: 'ConcurrentPassword123!',\n            firstName: 'Concurrent',\n            lastName: `User${index}`,\n            schoolId: testSchool.id,\n            role: 'STUDENT',\n          })\n      );\n\n      const responses = await Promise.all(loginPromises);\n      \n      // All registrations should succeed\n      responses.forEach((response, index) => {\n        expect(response.status).toBe(201);\n        expect(response.body.email).toBe(`concurrent${index}@test.com`);\n      });\n    });\n\n    it('should respond within reasonable time limits', async () => {\n      const start = Date.now();\n      \n      await request(app.getHttpServer())\n        .post('/auth/login')\n        .send({\n          email: testUser.email,\n          password: 'E2EPassword123!',\n        })\n        .expect(200);\n      \n      const end = Date.now();\n      const responseTime = end - start;\n      \n      // Authentication should complete within 2 seconds\n      expect(responseTime).toBeLessThan(2000);\n    });\n  });\n\n  describe('Error Handling and Recovery', () => {\n    it('should provide meaningful error messages', async () => {\n      // Test validation errors\n      const response = await request(app.getHttpServer())\n        .post('/auth/register')\n        .send({\n          email: 'test@test.com',\n          password: 'weak',\n          confirmPassword: 'different',\n          firstName: '',\n          lastName: '',\n          schoolId: 'invalid-uuid',\n          role: 'INVALID_ROLE',\n        })\n        .expect(400);\n\n      expect(response.body).toHaveProperty('message');\n      expect(Array.isArray(response.body.message) || typeof response.body.message === 'string').toBe(true);\n    });\n\n    it('should handle database connection issues gracefully', async () => {\n      // This test would require mocking database failures\n      // For now, we'll test that the application doesn't crash\n      // under normal circumstances\n      \n      const response = await request(app.getHttpServer())\n        .get('/auth/health')\n        .expect(200);\n      \n      expect(response.body.status).toBe('ok');\n    });\n\n    it('should handle malformed request bodies', async () => {\n      await request(app.getHttpServer())\n        .post('/auth/login')\n        .set('Content-Type', 'application/json')\n        .send('{ \"invalid\": json }')\n        .expect(400);\n    });\n  });\n});